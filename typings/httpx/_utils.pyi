"""
This type stub file was generated by pyright.
"""

import logging
import netrc
import re
import typing
from datetime import timedelta
from types import TracebackType
from ._types import PrimitiveData
from ._models import URL

if typing.TYPE_CHECKING:
    ...
_HTML5_FORM_ENCODING_REPLACEMENTS = { '"': "%22","\\": "\\\\" }
_HTML5_FORM_ENCODING_RE = re.compile(r"|".join([re.escape(c) for c in _HTML5_FORM_ENCODING_REPLACEMENTS.keys()]))
def normalize_header_key(value: typing.Union[str, bytes], encoding: str = ...) -> bytes:
    """
    Coerce str/bytes into a strictly byte-wise HTTP header key.
    """
    ...

def normalize_header_value(value: typing.Union[str, bytes], encoding: str = ...) -> bytes:
    """
    Coerce str/bytes into a strictly byte-wise HTTP header value.
    """
    ...

def str_query_param(value: PrimitiveData) -> str:
    """
    Coerce a primitive data type into a string value for query params.

    Note that we prefer JSON-style 'true'/'false' for boolean values here.
    """
    ...

def is_known_encoding(encoding: str) -> bool:
    """
    Return `True` if `encoding` is a known codec.
    """
    ...

def format_form_param(name: str, value: typing.Union[str, bytes]) -> bytes:
    """
    Encode a name/value pair within a multipart form.
    """
    ...

_null = b"\x00"
_null2 = _null * 2
_null3 = _null * 3
def guess_json_utf(data: bytes) -> typing.Optional[str]:
    ...

class NetRCInfo:
    def __init__(self, files: typing.Optional[typing.List[str]] = ...) -> None:
        ...
    
    @property
    def netrc_info(self) -> typing.Optional[netrc.netrc]:
        ...
    
    def get_credentials(self, authority: str) -> typing.Optional[typing.Tuple[str, str]]:
        ...
    


def get_ca_bundle_from_env() -> typing.Optional[str]:
    ...

def parse_header_links(value: str) -> typing.List[typing.Dict[str, str]]:
    """
    Returns a list of parsed link headers, for more info see:
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link
    The generic syntax of those is:
    Link: < uri-reference >; param1=value1; param2="value2"
    So for instance:
    Link; '<http:/.../front.jpeg>; type="image/jpeg",<http://.../back.jpeg>;'
    would return
        [
            {"url": "http:/.../front.jpeg", "type": "image/jpeg"},
            {"url": "http://.../back.jpeg"},
        ]
    :param value: HTTP Link entity-header field
    :return: list of parsed link headers
    """
    ...

SENSITIVE_HEADERS = "authorization", "proxy-authorization"
def obfuscate_sensitive_headers(items: typing.Iterable[typing.Tuple[typing.AnyStr, typing.AnyStr]]) -> typing.Iterator[typing.Tuple[typing.AnyStr, typing.AnyStr]]:
    ...

_LOGGER_INITIALIZED = False
TRACE_LOG_LEVEL = 5
class Logger(logging.Logger):
    def trace(self, message: str, *args: typing.Any, **kwargs: typing.Any) -> None:
        ...
    


def get_logger(name: str) -> Logger:
    """
    Get a `logging.Logger` instance, and optionally
    set up debug logging based on the HTTPX_LOG_LEVEL environment variable.
    """
    ...

def port_or_default(url: URL) -> typing.Optional[int]:
    ...

def same_origin(url: URL, other: URL) -> bool:
    """
    Return 'True' if the given URLs share the same origin.
    """
    ...

def get_environment_proxies() -> typing.Dict[str, typing.Optional[str]]:
    """Gets proxy information from the environment"""
    ...

def to_bytes(value: typing.Union[str, bytes], encoding: str = ...) -> bytes:
    ...

def to_str(value: typing.Union[str, bytes], encoding: str = ...) -> str:
    ...

def to_bytes_or_str(value: str, match_type_of: typing.AnyStr) -> typing.AnyStr:
    ...

def unquote(value: str) -> str:
    ...

def guess_content_type(filename: typing.Optional[str]) -> typing.Optional[str]:
    ...

def peek_filelike_length(stream: typing.IO) -> int:
    """
    Given a file-like stream object, return its length in number of bytes
    without reading it into memory.
    """
    ...

def flatten_queryparams(queryparams: typing.Mapping[str, typing.Union[PrimitiveData, typing.Sequence[PrimitiveData]]]) -> typing.List[typing.Tuple[str, PrimitiveData]]:
    """
    Convert a mapping of query params into a flat list of two-tuples
    representing each item.

    Example:
    >>> flatten_queryparams_values({"q": "httpx", "tag": ["python", "dev"]})
    [("q", "httpx), ("tag", "python"), ("tag", "dev")]
    """
    ...

class ElapsedTimer:
    def __init__(self) -> None:
        ...
    
    def __enter__(self) -> ElapsedTimer:
        ...
    
    def __exit__(self, exc_type: typing.Type[BaseException] = ..., exc_value: BaseException = ..., traceback: TracebackType = ...) -> None:
        ...
    
    @property
    def elapsed(self) -> timedelta:
        ...
    


class URLPattern:
    """
    A utility class currently used for making lookups against proxy keys...

    # Wildcard matching...
    >>> pattern = URLPattern("all")
    >>> pattern.matches(httpx.URL("http://example.com"))
    True

    # Witch scheme matching...
    >>> pattern = URLPattern("https")
    >>> pattern.matches(httpx.URL("https://example.com"))
    True
    >>> pattern.matches(httpx.URL("http://example.com"))
    False

    # With domain matching...
    >>> pattern = URLPattern("https://example.com")
    >>> pattern.matches(httpx.URL("https://example.com"))
    True
    >>> pattern.matches(httpx.URL("http://example.com"))
    False
    >>> pattern.matches(httpx.URL("https://other.com"))
    False

    # Wildcard scheme, with domain matching...
    >>> pattern = URLPattern("all://example.com")
    >>> pattern.matches(httpx.URL("https://example.com"))
    True
    >>> pattern.matches(httpx.URL("http://example.com"))
    True
    >>> pattern.matches(httpx.URL("https://other.com"))
    False

    # With port matching...
    >>> pattern = URLPattern("https://example.com:1234")
    >>> pattern.matches(httpx.URL("https://example.com:1234"))
    True
    >>> pattern.matches(httpx.URL("https://example.com"))
    False
    """
    def __init__(self, pattern: str) -> None:
        ...
    
    def matches(self, other: URL) -> bool:
        ...
    
    @property
    def priority(self) -> tuple:
        """
        The priority allows URLPattern instances to be sortable, so that
        we can match from most specific to least specific.
        """
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __lt__(self, other: URLPattern) -> bool:
        ...
    
    def __eq__(self, other: typing.Any) -> bool:
        ...
    


def warn_deprecated(message: str) -> None:
    ...

