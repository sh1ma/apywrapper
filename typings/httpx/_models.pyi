"""
This type stub file was generated by pyright.
"""

import datetime
import typing
from collections.abc import MutableMapping
from .__version__ import __version__
from ._content_streams import ContentStream
from ._decoders import Decoder, SUPPORTED_DECODERS
from ._types import CookieTypes, HeaderTypes, QueryParamTypes, RequestData, RequestFiles, URLTypes

class URL:
    def __init__(self, url: URLTypes = ..., params: QueryParamTypes = ...) -> None:
        ...
    
    @property
    def scheme(self) -> str:
        ...
    
    @property
    def authority(self) -> str:
        ...
    
    @property
    def userinfo(self) -> str:
        ...
    
    @property
    def username(self) -> str:
        ...
    
    @property
    def password(self) -> str:
        ...
    
    @property
    def host(self) -> str:
        ...
    
    @property
    def port(self) -> typing.Optional[int]:
        ...
    
    @property
    def path(self) -> str:
        ...
    
    @property
    def query(self) -> str:
        ...
    
    @property
    def full_path(self) -> str:
        ...
    
    @property
    def fragment(self) -> str:
        ...
    
    @property
    def raw(self) -> typing.Tuple[bytes, bytes, typing.Optional[int], bytes]:
        ...
    
    @property
    def is_ssl(self) -> bool:
        ...
    
    @property
    def is_absolute_url(self) -> bool:
        """
        Return `True` for absolute URLs such as 'http://example.com/path',
        and `False` for relative URLs such as '/path'.
        """
        ...
    
    @property
    def is_relative_url(self) -> bool:
        ...
    
    def copy_with(self, **kwargs: typing.Any) -> URL:
        ...
    
    def join(self, url: URLTypes) -> URL:
        """
        Return an absolute URL, using given this URL as the base.
        """
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other: typing.Any) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    


class QueryParams(typing.Mapping[str, str]):
    """
    URL query parameters, as a multi-dict.
    """
    def __init__(self, *args: QueryParamTypes, **kwargs: typing.Any) -> None:
        ...
    
    def keys(self) -> typing.KeysView:
        ...
    
    def values(self) -> typing.ValuesView:
        ...
    
    def items(self) -> typing.ItemsView:
        """
        Return all items in the query params. If a key occurs more than once
        only the first item for that key is returned.
        """
        ...
    
    def multi_items(self) -> typing.List[typing.Tuple[str, str]]:
        """
        Return all items in the query params. Allow duplicate keys to occur.
        """
        ...
    
    def get(self, key: typing.Any, default: typing.Any = ...) -> typing.Any:
        """
        Get a value from the query param for a given key. If the key occurs
        more than once, then only the first value is returned.
        """
        ...
    
    def get_list(self, key: typing.Any) -> typing.List[str]:
        """
        Get all values from the query param for a given key.
        """
        ...
    
    def update(self, params: QueryParamTypes = ...) -> None:
        ...
    
    def __getitem__(self, key: typing.Any) -> str:
        ...
    
    def __setitem__(self, key: str, value: str) -> None:
        ...
    
    def __contains__(self, key: typing.Any) -> bool:
        ...
    
    def __iter__(self) -> typing.Iterator[typing.Any]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __eq__(self, other: typing.Any) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def getlist(self, key: typing.Any) -> typing.List[str]:
        ...
    


class Headers(typing.MutableMapping[str, str]):
    """
    HTTP headers, as a case-insensitive multi-dict.
    """
    def __init__(self, headers: HeaderTypes = ..., encoding: str = ...) -> None:
        ...
    
    @property
    def encoding(self) -> str:
        """
        Header encoding is mandated as ascii, but we allow fallbacks to utf-8
        or iso-8859-1.
        """
        ...
    
    @encoding.setter
    def encoding(self, value: str) -> None:
        ...
    
    @property
    def raw(self) -> typing.List[typing.Tuple[bytes, bytes]]:
        """
        Returns a list of the raw header items, as byte pairs.
        May be mutated in-place.
        """
        ...
    
    def keys(self) -> typing.KeysView[str]:
        ...
    
    def values(self) -> typing.ValuesView[str]:
        ...
    
    def items(self) -> typing.ItemsView[str, str]:
        """
        Return `(key, value)` items of headers. Concatenate headers
        into a single comma seperated value when a key occurs multiple times.
        """
        ...
    
    def multi_items(self) -> typing.List[typing.Tuple[str, str]]:
        """
        Return a list of `(key, value)` pairs of headers. Allow multiple
        occurences of the same key without concatenating into a single
        comma seperated value.
        """
        ...
    
    def get(self, key: str, default: typing.Any = ...) -> typing.Any:
        """
        Return a header value. If multiple occurences of the header occur
        then concatenate them together with commas.
        """
        ...
    
    def get_list(self, key: str, split_commas: bool = ...) -> typing.List[str]:
        """
        Return a list of all header values for a given key.
        If `split_commas=True` is passed, then any comma seperated header
        values are split into multiple return strings.
        """
        ...
    
    def update(self, headers: HeaderTypes = ...) -> None:
        ...
    
    def copy(self) -> Headers:
        ...
    
    def __getitem__(self, key: str) -> str:
        """
        Return a single header value.

        If there are multiple headers with the same key, then we concatenate
        them with commas. See: https://tools.ietf.org/html/rfc7230#section-3.2.2
        """
        ...
    
    def __setitem__(self, key: str, value: str) -> None:
        """
        Set the header `key` to `value`, removing any duplicate entries.
        Retains insertion order.
        """
        ...
    
    def __delitem__(self, key: str) -> None:
        """
        Remove the header `key`.
        """
        ...
    
    def __contains__(self, key: typing.Any) -> bool:
        ...
    
    def __iter__(self) -> typing.Iterator[typing.Any]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __eq__(self, other: typing.Any) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def getlist(self, key: str, split_commas: bool = ...) -> typing.List[str]:
        ...
    


USER_AGENT = <Expression>
ACCEPT_ENCODING = ", ".join([key for key in SUPPORTED_DECODERS.keys() if key != "identity"])
class Request:
    def __init__(self, method: str, url: typing.Union[str, URL], *, params: QueryParamTypes = ..., headers: HeaderTypes = ..., cookies: CookieTypes = ..., data: RequestData = ..., files: RequestFiles = ..., json: typing.Any = ..., stream: ContentStream = ...) -> None:
        ...
    
    def prepare(self) -> None:
        ...
    
    @property
    def content(self) -> bytes:
        ...
    
    def read(self) -> bytes:
        """
        Read and return the request content.
        """
        ...
    
    async def aread(self) -> bytes:
        """
        Read and return the request content.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


class Response:
    def __init__(self, status_code: int, *, request: Request, http_version: str = ..., headers: HeaderTypes = ..., stream: ContentStream = ..., content: bytes = ..., history: typing.List[Response] = ...) -> None:
        ...
    
    @property
    def elapsed(self) -> datetime.timedelta:
        """
        Returns the time taken for the complete request/response
        cycle to complete.
        """
        ...
    
    @property
    def reason_phrase(self) -> str:
        ...
    
    @property
    def url(self) -> typing.Optional[URL]:
        """
        Returns the URL for which the request was made.
        """
        ...
    
    @property
    def content(self) -> bytes:
        ...
    
    @property
    def text(self) -> str:
        ...
    
    @property
    def encoding(self) -> str:
        ...
    
    @encoding.setter
    def encoding(self, value: str) -> None:
        ...
    
    @property
    def charset_encoding(self) -> typing.Optional[str]:
        """
        Return the encoding, as specified by the Content-Type header.
        """
        ...
    
    @property
    def apparent_encoding(self) -> typing.Optional[str]:
        """
        Return the encoding, as it appears to autodetection.
        """
        ...
    
    @property
    def decoder(self) -> Decoder:
        """
        Returns a decoder instance which can be used to decode the raw byte
        content, depending on the Content-Encoding used in the response.
        """
        ...
    
    @property
    def is_error(self) -> bool:
        ...
    
    @property
    def is_redirect(self) -> bool:
        ...
    
    def raise_for_status(self) -> None:
        """
        Raise the `HTTPStatusError` if one occurred.
        """
        ...
    
    def json(self, **kwargs: typing.Any) -> typing.Any:
        ...
    
    @property
    def cookies(self) -> Cookies:
        ...
    
    @property
    def links(self) -> typing.Dict[typing.Optional[str], typing.Dict[str, str]]:
        """
        Returns the parsed header links of the response, if any
        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    def read(self) -> bytes:
        """
        Read and return the response content.
        """
        ...
    
    def iter_bytes(self) -> typing.Iterator[bytes]:
        """
        A byte-iterator over the decoded response content.
        This allows us to handle gzip, deflate, and brotli encoded responses.
        """
        ...
    
    def iter_text(self) -> typing.Iterator[str]:
        """
        A str-iterator over the decoded response content
        that handles both gzip, deflate, etc but also detects the content's
        string encoding.
        """
        ...
    
    def iter_lines(self) -> typing.Iterator[str]:
        ...
    
    def iter_raw(self) -> typing.Iterator[bytes]:
        """
        A byte-iterator over the raw response content.
        """
        ...
    
    def next(self) -> Response:
        """
        Get the next response from a redirect response.
        """
        ...
    
    def close(self) -> None:
        """
        Close the response and release the connection.
        Automatically called if the response body is read to completion.
        """
        ...
    
    async def aread(self) -> bytes:
        """
        Read and return the response content.
        """
        ...
    
    async def aiter_bytes(self) -> typing.AsyncIterator[bytes]:
        """
        A byte-iterator over the decoded response content.
        This allows us to handle gzip, deflate, and brotli encoded responses.
        """
        ...
    
    async def aiter_text(self) -> typing.AsyncIterator[str]:
        """
        A str-iterator over the decoded response content
        that handles both gzip, deflate, etc but also detects the content's
        string encoding.
        """
        ...
    
    async def aiter_lines(self) -> typing.AsyncIterator[str]:
        ...
    
    async def aiter_raw(self) -> typing.AsyncIterator[bytes]:
        """
        A byte-iterator over the raw response content.
        """
        ...
    
    async def anext(self) -> Response:
        """
        Get the next response from a redirect response.
        """
        ...
    
    async def aclose(self) -> None:
        """
        Close the response and release the connection.
        Automatically called if the response body is read to completion.
        """
        ...
    


class Cookies(MutableMapping):
    """
    HTTP Cookies, as a mutable mapping.
    """
    def __init__(self, cookies: CookieTypes = ...) -> None:
        ...
    
    def extract_cookies(self, response: Response) -> None:
        """
        Loads any cookies based on the response `Set-Cookie` headers.
        """
        ...
    
    def set_cookie_header(self, request: Request) -> None:
        """
        Sets an appropriate 'Cookie:' HTTP header on the `Request`.
        """
        ...
    
    def set(self, name: str, value: str, domain: str = ..., path: str = ...) -> None:
        """
        Set a cookie value by name. May optionally include domain and path.
        """
        ...
    
    def get(self, name: str, default: str = ..., domain: str = ..., path: str = ...) -> typing.Optional[str]:
        """
        Get a cookie by name. May optionally include domain and path
        in order to specify exactly which cookie to retrieve.
        """
        ...
    
    def delete(self, name: str, domain: str = ..., path: str = ...) -> None:
        """
        Delete a cookie by name. May optionally include domain and path
        in order to specify exactly which cookie to delete.
        """
        ...
    
    def clear(self, domain: str = ..., path: str = ...) -> None:
        """
        Delete all cookies. Optionally include a domain and path in
        order to only delete a subset of all the cookies.
        """
        ...
    
    def update(self, cookies: CookieTypes = ...) -> None:
        ...
    
    def __setitem__(self, name: str, value: str) -> None:
        ...
    
    def __getitem__(self, name: str) -> str:
        ...
    
    def __delitem__(self, name: str) -> None:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __iter__(self) -> typing.Iterator[str]:
        ...
    
    def __bool__(self) -> bool:
        ...
    
    class _CookieCompatRequest(urllib.request.Request):
        """
        Wraps a `Request` instance up in a compatibility interface suitable
        for use with `CookieJar` operations.
        """
        def __init__(self, request: Request) -> None:
            ...
        
        def add_unredirected_header(self, key: str, value: str) -> None:
            ...
        
    
    
    class _CookieCompatResponse:
        """
        Wraps a `Request` instance up in a compatibility interface suitable
        for use with `CookieJar` operations.
        """
        def __init__(self, response: Response) -> None:
            ...
        
        def info(self) -> email.message.Message:
            ...
        
    
    


