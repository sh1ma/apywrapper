"""
This type stub file was generated by pyright.
"""

import contextlib
import typing
import httpcore
from ._models import Request, Response

"""
Our exception hierarchy:

* HTTPError
  x RequestError
    + TransportError
      - TimeoutException
        · ConnectTimeout
        · ReadTimeout
        · WriteTimeout
        · PoolTimeout
      - NetworkError
        · ConnectError
        · ReadError
        · WriteError
        · CloseError
      - ProtocolError
        · LocalProtocolError
        · RemoteProtocolError
      - ProxyError
      - UnsupportedProtocol
    + DecodingError
    + TooManyRedirects
    + RequestBodyUnavailable
  x HTTPStatusError
* InvalidURL
* NotRedirectResponse
* CookieConflict
* StreamError
  x StreamConsumed
  x ResponseNotRead
  x RequestNotRead
  x ResponseClosed
"""
if typing.TYPE_CHECKING:
    ...
class HTTPError(Exception):
    """
    Base class for `RequestError` and `HTTPStatusError`.

    Useful for `try...except` blocks when issuing a request,
    and then calling `.raise_for_status()`.

    For example:

    ```
    try:
        response = httpx.get("https://www.example.com")
        response.raise_for_status()
    except httpx.HTTPError as exc:
        print(f"HTTP Exception for {exc.request.url} - {exc.message}")
    ```
    """
    def __init__(self, message: str, *, request: Request) -> None:
        ...
    


class RequestError(HTTPError):
    """
    Base class for all exceptions that may occur when issuing a `.request()`.
    """
    def __init__(self, message: str, *, request: Request) -> None:
        ...
    


class TransportError(RequestError):
    """
    Base class for all exceptions that occur at the level of the Transport API.

    All of these exceptions also have an equivelent mapping in `httpcore`.
    """
    ...


class TimeoutException(TransportError):
    """
    The base class for timeout errors.

    An operation has timed out.
    """
    ...


class ConnectTimeout(TimeoutException):
    """
    Timed out while connecting to the host.
    """
    ...


class ReadTimeout(TimeoutException):
    """
    Timed out while receiving data from the host.
    """
    ...


class WriteTimeout(TimeoutException):
    """
    Timed out while sending data to the host.
    """
    ...


class PoolTimeout(TimeoutException):
    """
    Timed out waiting to acquire a connection from the pool.
    """
    ...


class NetworkError(TransportError):
    """
    The base class for network-related errors.

    An error occurred while interacting with the network.
    """
    ...


class ReadError(NetworkError):
    """
    Failed to receive data from the network.
    """
    ...


class WriteError(NetworkError):
    """
    Failed to send data through the network.
    """
    ...


class ConnectError(NetworkError):
    """
    Failed to establish a connection.
    """
    ...


class CloseError(NetworkError):
    """
    Failed to close a connection.
    """
    ...


class ProxyError(TransportError):
    """
    An error occurred while establishing a proxy connection.
    """
    ...


class UnsupportedProtocol(TransportError):
    """
    Attempted to make a request to an unsupported protocol.

    For example issuing a request to `ftp://www.example.com`.
    """
    ...


class ProtocolError(TransportError):
    """
    The protocol was violated.
    """
    ...


class LocalProtocolError(ProtocolError):
    """
    A protocol was violated by the client.

    For example if the user instantiated a `Request` instance explicitly,
    failed to include the mandatory `Host:` header, and then issued it directly
    using `client.send()`.
    """
    ...


class RemoteProtocolError(ProtocolError):
    """
    The protocol was violated by the server.

    For exaample, returning malformed HTTP.
    """
    ...


class DecodingError(RequestError):
    """
    Decoding of the response failed, due to a malformed encoding.
    """
    ...


class TooManyRedirects(RequestError):
    """
    Too many redirects.
    """
    ...


class RequestBodyUnavailable(RequestError):
    """
    Had to send the request again, but the request body was streaming, and is
    no longer available.
    """
    ...


class HTTPStatusError(HTTPError):
    """
    The response had an error HTTP status of 4xx or 5xx.

    May be raised when calling `response.raise_for_status()`
    """
    def __init__(self, message: str, *, request: Request, response: Response) -> None:
        ...
    


class InvalidURL(Exception):
    """
    URL is improperly formed or cannot be parsed.
    """
    def __init__(self, message: str) -> None:
        ...
    


class NotRedirectResponse(Exception):
    """
    Response was not a redirect response.

    May be raised if `response.next()` is called without first
    properly checking `response.is_redirect`.
    """
    def __init__(self, message: str) -> None:
        ...
    


class CookieConflict(Exception):
    """
    Attempted to lookup a cookie by name, but multiple cookies existed.

    Can occur when calling `response.cookies.get(...)`.
    """
    def __init__(self, message: str) -> None:
        ...
    


class StreamError(Exception):
    """
    The base class for stream exceptions.

    The developer made an error in accessing the request stream in
    an invalid way.
    """
    def __init__(self, message: str) -> None:
        ...
    


class StreamConsumed(StreamError):
    """
    Attempted to read or stream response content, but the content has already
    been streamed.
    """
    def __init__(self) -> None:
        ...
    


class ResponseNotRead(StreamError):
    """
    Attempted to access response content, without having called `read()`
    after a streaming response.
    """
    def __init__(self) -> None:
        ...
    


class RequestNotRead(StreamError):
    """
    Attempted to access request content, without having called `read()`.
    """
    def __init__(self) -> None:
        ...
    


class ResponseClosed(StreamError):
    """
    Attempted to read or stream response content, but the request has been
    closed.
    """
    def __init__(self) -> None:
        ...
    


@contextlib.contextmanager
def map_exceptions(mapping: typing.Mapping[typing.Type[Exception], typing.Type[Exception]], **kwargs: typing.Any) -> typing.Iterator[None]:
    ...

HTTPCORE_EXC_MAP = { httpcore.TimeoutException: TimeoutException,httpcore.ConnectTimeout: ConnectTimeout,httpcore.ReadTimeout: ReadTimeout,httpcore.WriteTimeout: WriteTimeout,httpcore.PoolTimeout: PoolTimeout,httpcore.NetworkError: NetworkError,httpcore.ConnectError: ConnectError,httpcore.ReadError: ReadError,httpcore.WriteError: WriteError,httpcore.CloseError: CloseError,httpcore.ProxyError: ProxyError,httpcore.UnsupportedProtocol: UnsupportedProtocol,httpcore.ProtocolError: ProtocolError,httpcore.LocalProtocolError: LocalProtocolError,httpcore.RemoteProtocolError: RemoteProtocolError }
