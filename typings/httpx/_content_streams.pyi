"""
This type stub file was generated by pyright.
"""

import typing
import httpcore
from ._types import FileTypes, RequestData, RequestFiles

class ContentStream(httpcore.AsyncByteStream, httpcore.SyncByteStream):
    def get_headers(self) -> typing.Dict[str, str]:
        """
        Return a dictionary of headers that are implied by the encoding.
        """
        ...
    
    def can_replay(self) -> bool:
        """
        Return `True` if `__aiter__` can be called multiple times.

        We need this in cases such determining if we can re-issue a request
        body when we receive a redirect response.
        """
        ...
    
    def __iter__(self) -> typing.Iterator[bytes]:
        ...
    
    def close(self) -> None:
        ...
    
    async def __aiter__(self) -> typing.AsyncIterator[bytes]:
        ...
    
    async def aclose(self) -> None:
        ...
    


class ByteStream(ContentStream):
    """
    Request content encoded as plain bytes.
    """
    def __init__(self, body: typing.Union[str, bytes]) -> None:
        ...
    
    def get_headers(self) -> typing.Dict[str, str]:
        ...
    
    def __iter__(self) -> typing.Iterator[bytes]:
        ...
    
    async def __aiter__(self) -> typing.AsyncIterator[bytes]:
        ...
    


class IteratorStream(ContentStream):
    """
    Request content encoded as plain bytes, using an byte iterator.
    """
    def __init__(self, iterator: typing.Iterator[bytes], close_func: typing.Callable = ...) -> None:
        ...
    
    def can_replay(self) -> bool:
        ...
    
    def get_headers(self) -> typing.Dict[str, str]:
        ...
    
    def __iter__(self) -> typing.Iterator[bytes]:
        ...
    
    def __aiter__(self) -> typing.AsyncIterator[bytes]:
        ...
    
    def close(self) -> None:
        ...
    


class AsyncIteratorStream(ContentStream):
    """
    Request content encoded as plain bytes, using an async byte iterator.
    """
    def __init__(self, aiterator: typing.AsyncIterator[bytes], close_func: typing.Callable = ...) -> None:
        ...
    
    def can_replay(self) -> bool:
        ...
    
    def get_headers(self) -> typing.Dict[str, str]:
        ...
    
    def __iter__(self) -> typing.Iterator[bytes]:
        ...
    
    async def __aiter__(self) -> typing.AsyncIterator[bytes]:
        ...
    
    async def aclose(self) -> None:
        ...
    


class JSONStream(ContentStream):
    """
    Request content encoded as JSON.
    """
    def __init__(self, json: typing.Any) -> None:
        ...
    
    def get_headers(self) -> typing.Dict[str, str]:
        ...
    
    def __iter__(self) -> typing.Iterator[bytes]:
        ...
    
    async def __aiter__(self) -> typing.AsyncIterator[bytes]:
        ...
    


class URLEncodedStream(ContentStream):
    """
    Request content as URL encoded form data.
    """
    def __init__(self, data: dict) -> None:
        ...
    
    def get_headers(self) -> typing.Dict[str, str]:
        ...
    
    def __iter__(self) -> typing.Iterator[bytes]:
        ...
    
    async def __aiter__(self) -> typing.AsyncIterator[bytes]:
        ...
    


class MultipartStream(ContentStream):
    """
    Request content as streaming multipart encoded form data.
    """
    class DataField:
        """
        A single form field item, within a multipart form field.
        """
        def __init__(self, name: str, value: typing.Union[str, bytes]) -> None:
            ...
        
        def render_headers(self) -> bytes:
            ...
        
        def render_data(self) -> bytes:
            ...
        
        def get_length(self) -> int:
            ...
        
        def can_replay(self) -> bool:
            ...
        
        def render(self) -> typing.Iterator[bytes]:
            ...
        
    
    
    class FileField:
        """
        A single file field item, within a multipart form field.
        """
        def __init__(self, name: str, value: FileTypes) -> None:
            ...
        
        def get_length(self) -> int:
            ...
        
        def render_headers(self) -> bytes:
            ...
        
        def render_data(self) -> typing.Iterator[bytes]:
            ...
        
        def can_replay(self) -> bool:
            ...
        
        def render(self) -> typing.Iterator[bytes]:
            ...
        
    
    
    def __init__(self, data: typing.Mapping, files: RequestFiles, boundary: bytes = ...) -> None:
        ...
    
    def iter_chunks(self) -> typing.Iterator[bytes]:
        ...
    
    def iter_chunks_lengths(self) -> typing.Iterator[int]:
        ...
    
    def get_content_length(self) -> int:
        ...
    
    def can_replay(self) -> bool:
        ...
    
    def get_headers(self) -> typing.Dict[str, str]:
        ...
    
    def __iter__(self) -> typing.Iterator[bytes]:
        ...
    
    async def __aiter__(self) -> typing.AsyncIterator[bytes]:
        ...
    


def encode(data: RequestData = ..., files: RequestFiles = ..., json: typing.Any = ..., boundary: bytes = ...) -> ContentStream:
    """
    Handles encoding the given `data`, `files`, and `json`, returning
    a `ContentStream` implementation.
    """
    ...

